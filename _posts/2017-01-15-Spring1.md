---
layout: post
comments: true
title: "스프링은 DI라는 결론..."
categories:
- blog
---



# 스프링은 DI다.

## 오브젝트와 의존관계

* 스프링 -> 오브젝트 -> 오브젝트의 설계
* 오브젝트의 주기 : 생성 - 관계 - 사용 - 소멸

## 오브젝트 설계

1. 객체지향 설계
2. 디자인 패턴
3. 리팩토링
4. 단위 테스트

--> 1, 2 는 효과적인 설계 및 구현 // 3, 4는 개선이 목적이다.

## DAO(Data Access Object)

* DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전담한다.
* Java Bean : <span style="color:#e73e3e">뒤에서 설명할 예정</span>
* DAO클래스에서는..
    * DB연결 - SQL을 담은 Statement - 실행 - Object화의 4단계를 거치며
    사이사이 예외처리가 필요하다.
* 관심사의 분리
    * DB 커넥션에서 : 어떤 DB?, 어떤 드라이버?, 어떤 로그인? 에 따라 커넥션의 구현이 달라진다.
    * Statement또한...
    * 어떻게 분리할까???? : 메소드분리 / 상속이나 인터페이스를 이용해서

<span style="color:#fbca4; ">_템플릿 메소드 패턴__</span>
_팩토리 메소드 패턴__ <-- 나중에

* 변화의 성격은 다르다: 왜 / 시기 / 주기등
* 리팩토링 -> 기능의 변화는 없이 검증을 한다
* 클래스 분리 + 상속x + 공통 메소드 네임 + 제공되는 클래스 이름
이걸 어떻게 할까????? 답은 인터페이스다.
    * 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 갖고 구현 내용에는 신경을 쓰지 말자!
* 관계설정 책임의 분리 : 클라이언트에게 인터페이스로 클래스 생성을 하게 되면 그것을 메소드 호출을 한다. Interface test = new Class() (- Class는 Interface를 상속받음)

### 원칙에는 무엇이...?

* 개방 폐쇄원칙(OCP) : 클래스나 모듈은 확장에는 열려있고 변경에는 닫혀있어야 한다.
* 높은 응집도와 낮은 결합도
* 높은 응집도 : 하나의 모듈, 클래스가 하나의 책인 or 관심사에만 집중되어 있다.
=> 응집도를 높였다는 것은 어떤 변경에 대해 일어날 변화 가능성의 코드들을 한데 묶어 모듈화 시켰다는 것이다.
* 낮은 결합도 : 관계를 유지시키는 데 꼭 필요한 것을 제외한 나머지 기능 혹은 그 무언가에 대해서 서로 분리시켜 결합도를 낮추는 것이다.
* 전략패턴: 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 패턴

## 1.4 제어의 역전(IoC, Inverse of Control)

### 팩토리 <=> 추상팩토리 패턴, 팩토리 메소드 패턴

* 객체의 생성방법을 결정하고, 그렇게 만들어진 오브젝트를 반환하는 것

### 제어의 역전이란?<span style="color:#e11d21">(중요개념)</span>

```
* 일반적인 main에서 시작해서 등등의 흐름이 아니라 오브젝트 자신이 사용할 오브젝트를 스스로 선택하지 않는다.(생성x)
=> 모든 제어 권한을 다른 어떤 대상에게 위임한다.
```

_재차 설명!_

```
* 어떤한 일을 하도록 만들어진 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경써야 할 것을 줄이는 전략이다.
(라이브러리 : 사용자메소드에서 라이브러리를 사용한다. /// 프레임워크 : 프레임워크가 사용자메소드를 사용한다.)
```

_어떤 방법으로???_

```
1. 프레임워크에 내가 작성한 메소드를 등록
2. 프레임워크에 정의되어 있는 인터페이스, 추상타입을 나의 코드에서 구현 or 상속한 후 프레임워크에 넘겨주는 것
==> 객체를 프레임워크에 주입하는 것 // 의존을 주입하는 것(Dependency Injection)
```

## 1.5 스프링의 IoC

### bean

* 스프링이 제어권을 갖고 직접만들고 관계를 부여하는 오브젝트
=> 오브젝트 단위의 애플리케이션 컴포넌트

### 스프링 bean

* 스프링 컨테이너가 생성과 관계를 설정하고, 사용등을 제어해주는 오브젝트(IoC가 적용됨)

### IoC오브젝트를 빈팩토리 or 애플리케이션 컨텍스트 or IoC 컨테이너라 함

### 스프링 IoC의 장점

* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 x
* 애플리케이션 컨텍스트는 종합 IoC서비스를 제공
* 빈을 검색하는 다양한 방법 제공

### 용어 설명

* bean : "스프링"이 IoC방식으로 관리하는 오브젝트
* bean factory : 스프링의 IoC를 담당하는 핵심 컨테이너(클래스로는 BeanFactory)
=> 등록, 생성, 조회, 반환등의 기능을 함
* Application Context(BeanFactory를 상속함)
=> 빈 팩토리를 확장한 IoC컨테이너 즉, 스프링이 제공하는 애플리케이션 지원 가능

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 싱글톤 레지스트로서의 애플리케이션 컨텍스트

* 왜 스프링을 싱글톤으로 만드는가?
=> 스프링은 일반적으로 서버환경이고, 다수의 사용자가 접근한다. 이 때마다 오브젝트를 생성하는 것은 문제가 많다.(서버부하등..)
따라서 싱글톤으로 두고, 멀티 스레드 방식으로 구현한다.

### 싱글톤 패턴(싱글톤 레지스트리와는 다름)

* 상속 x (왜???? private 선언이므로)
* 하나 이상의 오브젝트가 생성될 가능성이 존재
* 테스트를 하기 힘들다.
* 전역적으로 사용하기 때문에 나쁘다.

_참고로_ GoF에서도 싱글톤 패턴을 조심스럽게 사용해야 한다고 말하고 있음.

> **결론** : 싱글톤 레지스트리는 이러한 문제점을 없애면서 싱글톤으로 관리가 가능함

## 1.7 의존관계 주입(Dependency Injection)

### <span style="color:#a5181a">이걸 설명하기 위해 1장의 그 방대한 내용을 풀어놓은 것 같다.</span>

### 의존이란?

* "A가 B에게 의존하고 있다." 즉, B가 변하면 A에게 영향을 미친다는 것

### 의존관계 주입

* 제 3자에게 특정 오브젝트를 사용하겠다는 결정과 관리를 넘겨주고, 자신은 인터페이스만 사용한다.
* 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 넣는다.
**_주입한다는 것은?_** : 한 군데만 바꾸어주어도 충분하다는 뜻 // **스프링에서 추구하고 있는 가장 큰 핵심**

### 의존관계 검색

* 검색하는 오브젝트는 자신이 스프링의 Bean일 필요가 없다.(DI와의 가장 큰 차이)
즉, 어디서나 생성한 인스턴스가 호출가능하고 @ Bean이 없어도 된다.

### 의존관계 주입의 응용

* 기능구현의 교환
* 부가기능의 추가
* 메소드를 이용한 DI
    * 설정자의 경우 parameter가 1개밖에 없다 여러개로 하고 싶다면 아래 생성자를 이용하자.
* 생성자를 이용한 DI
    * 클래스에 정의된 인스턴스개수만큼 DI가 가능하다.
    * 여러개이기 때문에 조심도 해야함


## 1.8 XML을 이용한 삽입

### < beans > : 여러개의 bean이 담긴 집합 // 아래는 속성

* bean이름
* bean의 클래스
* bean의 의존클래스

### < property > : 메소드를 정의함

예시)
userDao.setConnectionMaker( connectionMaker() );
--- 바꾸면 --- 
```
<beans>
	<bean>
	</bean>
	
	<bean id = "userDao" class = "springbook.dao.UserDao">
		<property name = "connectionMaker" ref = "connectionMaker" />
	</bean>
</beans>
```

```
<bean id = "메소드 이름" class = "리턴객체의 타입">
	<property name = "bean id에서 사용하는 메소드 이름" ref = " 인자로 DI가 되는 대상 객체" />
</bean>

name : DI를 하는 대상
ref : DI를 당하는 대상
```
