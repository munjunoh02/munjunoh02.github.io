---
layout: post
comments: true
title: "Actor 프로그래밍"
date: 2017-07-08
tags: 프로그래밍
---

## 액터 프로그래밍

위키백과같은 것들을 찾아보면, 액터 프로그래밍을 아래와 같은 프로그래밍 기법으로 정의를 하고 있다.
```
	-	다른 액터에 한정된 개수의 메세지 전달
	-	받을 메세지에 액터가 수반될 행동을 지정할 수 있음
	-	이런 일들이 동작을 하는데, 정해진 순서는 없음
```
객체지향적인 프로그래밍을 하다보니... `객체의 재사용을 위해서 어떻게 프로그래밍을 할까?`라는 질문을 던졌었다.  
그런데, 액터 프로그래밍을 만나고, 처음에는 헷갈렸지만, 지금 내가 정의하는 액터프로그래밍은 `메세징 프로그래밍`이다.  
`객체가 중심이 되는 것이 아니라, 전달되는 메세지가 중심이 되는 프로그래밍`인 것이다.  

### 액터 프로그래밍의 첫 번째 특징은 `비동기 프로그래밍`
실생활에서 우리가 메세지를 전달하고 기다리지 않듯이, 액터 프로그래밍도 메세지가 중심이 되는 프로그래밍이기 때문에 기다리지 않아도 된다.
### 액터 프로그래밍의 두 번째 특징은 `동시성 제어가 필요 없는 멀티 프로그래밍`
동시성 프로그래밍을 할 때, 사실 가장 신경써야하고 짜증나는 부분이 `공유자원 관리`이다.  
액터 프로그래밍은 `sender - mailbox - receiver`로 구성되어 있다.
```
메세지를 주고받을 때, 직접 주고받는 것이 아니라 사이에 mailbox가 존재하여,
sender는 메일박스에 메세지를 쌓아두고,
receiver는 메일박스에 메세지가 있으면 일을 하고, 메세지가 없으면 일을 하지 않는다.
이 떄, receiver는 그 순간에 "하나의 메세지" 만 처리한다.
```
한 번에 하나의 메세지만 처리할 수 있는 receiver의 특성과 비동기 프로그래밍이기 때문에, 그냥 메세지만 전달하면 된다. 그게 끝이다. 여러 메세지를 전달만 하면된다.  

**사실, Actor의 경우에는 동시성 프로그래밍을 지향하지는 않지만, 너무 좋은 모델이긴하다.**

### 액터 프로그래밍의 세 번째 특징은 `파이프라이닝`
액터는 메세지를 전달받고, 그 메세지만 처리하면 된다.  
A, B, C의 액터에서 동작하는 일의 처리시간은 각각 다르고 메세지마다 다르다.  
그렇기 때문에, A -> B -> C의 순으로 동작하는 프로그래밍이라면, 액터별 메일박스에 쌓여있는 메세지를 아래와 같이 볼 수 있다.  

|메세지 개수|A|B|C|처리결과|
|:---:|:---:|:---:|:---:|:---:|
|1|1|0|0|0|
|2|1|1|0|0|
|3|1|1|1|0|
|4|1|1|1|1|
|5|1|1|2|1|
|6|1|2|2|1|
|7|1|0|2|4|

그냥, 메세지를 처리하고 결과만 전달하면 된다.  

> 다음에는 액터프로그래밍을 제대로 구현하고 있는 AKKA를 써봐야 할 것 같다.
